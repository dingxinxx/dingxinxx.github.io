<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RN手势响应系统总结</title>
      <link href="/2019/06/05/RN%E6%89%8B%E5%8A%BF%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/05/RN%E6%89%8B%E5%8A%BF%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="响应者的生命周期"><a href="#响应者的生命周期" class="headerlink" title="响应者的生命周期"></a>响应者的生命周期</h2><h3 id="生命周期方法列表"><a href="#生命周期方法列表" class="headerlink" title="生命周期方法列表"></a>生命周期方法列表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">View.props.onStartShouldSetResponderCapture: <span class="function">(<span class="params">evt</span>) =&gt;</span> <span class="literal">true</span> </span><br><span class="line">View.props.onMoveShouldSetResponderCapture: <span class="function">(<span class="params">evt</span>) =&gt;</span> <span class="literal">true</span></span><br><span class="line">View.props.onStartShouldSetResponder: <span class="function">(<span class="params">evt</span>) =&gt;</span> <span class="literal">true</span></span><br><span class="line">View.props.onMoveShouldSetResponder: <span class="function">(<span class="params">evt</span>) =&gt;</span> <span class="literal">true</span></span><br><span class="line">View.props.onResponderGrant: <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">View.props.onResponderReject: <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">View.props.onResponderMove: <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">View.props.onResponderRelease: <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">View.props.onResponderTerminationRequest: <span class="function">(<span class="params">evt</span>) =&gt;</span> <span class="literal">true</span></span><br><span class="line">View.props.onResponderTerminate: <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>evt是一个合成事件，它包含以下结构：</p><ul><li>nativeEvent<ul><li>changedTouches - 在上一次事件之后，所有发生变化的触摸事件的数组集合（即上一次事件后，所有移动过的触摸点）</li><li>identifier - 触摸点的 ID</li><li>locationX - 触摸点相对于当前元素的横坐标</li><li>locationY - 触摸点相对于当前元素的纵坐标</li><li>pageX - 触摸点相对于根元素的横坐标</li><li>pageY - 触摸点相对于根元素的纵坐标</li><li>target - 触摸点所在的元素 ID</li><li>timestamp - 触摸事件的时间戳，可用于移动速度的计算</li><li>touches - 当前屏幕上的所有触摸点的集合</li></ul></li></ul><a id="more"></a><h3 id="生命周期方法详解"><a href="#生命周期方法详解" class="headerlink" title="生命周期方法详解"></a>生命周期方法详解</h3><h4 id="捕获-ShouldSet-事件处理"><a href="#捕获-ShouldSet-事件处理" class="headerlink" title="捕获 ShouldSet 事件处理"></a>捕获 ShouldSet 事件处理</h4><ul><li><code>View.props.onStartShouldSetResponderCapture: (evt) =&gt; true</code> </li><li><code>View.props.onMoveShouldSetResponderCapture: (evt) =&gt; true</code></li></ul><blockquote><p>“是否愿意成为响应者”系列方法：onStartShouldSetResponder与onMoveShouldSetResponder是以冒泡的形式调用的，即嵌套最深的节点最先调用。这意味着当多个 View 同时在*ShouldSetResponder中返回 true 时，最底层的 View 将优先“夺权”。在多数情况下这并没有什么问题，因为这样可以确保所有控件和按钮是可用的。</p></blockquote><blockquote><p>但是有些时候，某个父 View 会希望能先成为响应者。我们可以利用“捕获期”来解决这一需求。响应系统在从最底层的组件开始冒泡之前，会首先执行一个“捕获期”，在此期间会触发on*ShouldSetResponderCapture系列事件。因此，如果某个父 View 想要在触摸操作开始时阻止子组件成为响应者，那就应该处理onStartShouldSetResponderCapture事件并返回 true 值。</p></blockquote><h4 id="是否愿意成为响应者"><a href="#是否愿意成为响应者" class="headerlink" title="是否愿意成为响应者"></a>是否愿意成为响应者</h4><ul><li><code>View.props.onStartShouldSetResponder: (evt) =&gt; true</code> 在用户开始触摸的时候（手指刚刚接触屏幕的瞬间），是否愿意成为响应者？</li><li><code>View.props.onMoveShouldSetResponder: (evt) =&gt; true</code> 如果 View 不是响应者，那么在每一个触摸点开始移动（没有停下也没有离开屏幕）时再询问一次：是否愿意响应触摸交互呢？</li></ul><h4 id="尝试成为响应者"><a href="#尝试成为响应者" class="headerlink" title="尝试成为响应者"></a>尝试成为响应者</h4><ul><li><code>View.props.onResponderGrant: (evt) =&gt; {}</code> View 现在要开始响应触摸事件了。这也是需要做高亮的时候，使用户知道他到底点到了哪里</li><li><code>View.props.onResponderReject: (evt) =&gt; {}</code> 响应者现在“另有其人”而且暂时不会“放权”，请另作安排。</li></ul><h4 id="开始响应触摸事件"><a href="#开始响应触摸事件" class="headerlink" title="开始响应触摸事件"></a>开始响应触摸事件</h4><ul><li><code>View.props.onResponderMove: (evt) =&gt; {}</code> 用户正在屏幕上移动手指时（没有停下也没有离开屏幕）。</li><li><code>View.props.onResponderRelease: (evt) =&gt; {}</code> 触摸操作结束时触发，比如”touchUp”（手指抬起离开屏幕）。</li><li><code>View.props.onResponderTerminationRequest: (evt) =&gt; true</code> 有其他组件请求接替响应者，当前的 View 是否“放权”？返回 true 的话则释放响应者权力。</li><li><code>View.props.onResponderTerminate: (evt) =&gt; {}</code>  响应者权力已经交出。这可能是由于其他 View 通过<strong>onResponderTerminationRequest</strong>请求的，也可能是由操作系统强制夺权（比如 iOS 上的控制中心或是通知中心）。</li></ul><h2 id="封装手势"><a href="#封装手势" class="headerlink" title="封装手势"></a>封装手势</h2><p>可以认为是对手势响应生命周期方法的模板封装,与gesture responder system 比起来，<code>封装手势</code>方法的抽象程度更高，使用起来也更加方便</p><h3 id="PanResponder"><a href="#PanResponder" class="headerlink" title="PanResponder"></a>PanResponder</h3><h4 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h4><h5 id="事件方法列表"><a href="#事件方法列表" class="headerlink" title="事件方法列表"></a>事件方法列表</h5><ol><li>onMoveShouldSetPanResponder: (evt, gestureState) =&gt; {…}</li><li>onMoveShouldSetPanResponderCapture: (evt, gestureState) =&gt; {…}</li><li>onStartShouldSetPanResponder: (evt, gestureState) =&gt; {…}</li><li>onStartShouldSetPanResponderCapture: (evt, gestureState) =&gt; {…}</li><li>onPanResponderReject: (evt, gestureState) =&gt; {…}</li><li>onPanResponderGrant: (evt, gestureState) =&gt; {…}</li><li>onPanResponderStart: (evt, gestureState) =&gt; {…}</li><li>onPanResponderEnd: (evt, gestureState) =&gt; {…}</li><li>onPanResponderRelease: (evt, gestureState) =&gt; {…} //用户手指离开屏幕时，调用该方法</li><li>onPanResponderMove: (evt, gestureState) =&gt; {…} //用户滑动手指时，调用该方法</li><li>onPanResponderTerminate: (evt, gestureState) =&gt; {…}</li><li>onPanResponderTerminationRequest: (evt, gestureState) =&gt; {…}</li><li>onShouldBlockNativeResponder: (evt, gestureState) =&gt; {…}</li></ol><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5><ul><li><p>相比gesture responder syste的响应事件方法多了一个<strong>gestureState</strong>对象参数。</p><blockquote><p>例如：<code>onPanResponderMove: (event, gestureState) =&gt; {}</code></p></blockquote></li><li><p>一个<strong>gestureState</strong>对象有如下的字段：</p><ul><li>stateID - 触摸状态的 ID。在屏幕上有至少一个触摸点的情况下，这个 ID 会一直有效。</li><li>moveX - 最近一次移动时的屏幕横坐标</li><li>moveY - 最近一次移动时的屏幕纵坐标</li><li>x0 - 当响应器产生时的屏幕坐标</li><li>y0 - 当响应器产生时的屏幕坐标</li><li>dx - 从触摸操作开始时的累计横向路程</li><li>dy - 从触摸操作开始时的累计纵向路程</li><li>vx - 当前的横向移动速度</li><li>vy - 当前的纵向移动速度</li><li>numberActiveTouches - 当前在屏幕上的有效触摸点的数量</li></ul></li><li><p>两个参数的作用</p><ul><li>evt<ul><li>获取触摸的位置在被响应的 View 中的相对坐标</li><li>evt.nativeEvent.locationX 和 evt.nativeEvent.locationY（这个方法很实用）  </li></ul></li><li>gestureState<ul><li>dx/dy：手势进行到现在的横向/纵向相对位移 </li><li>vx/vy：此刻的横向/纵向速度 </li><li>numberActiveTouches：responder上的触摸的个数</li></ul></li></ul></li></ul><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._panResponder = PanResponder.create(&#123;</span><br><span class="line">    <span class="comment">// 要求成为响应者：</span></span><br><span class="line">    onStartShouldSetPanResponder: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">    onStartShouldSetPanResponderCapture: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">    onMoveShouldSetPanResponder: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">    onMoveShouldSetPanResponderCapture: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    onPanResponderGrant: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 开始手势操作。给用户一些视觉反馈，让他们知道发生了什么事情！</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// gestureState.&#123;x,y&#125; 现在会被设置为0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onPanResponderMove: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 最近一次的移动距离为gestureState.move&#123;X,Y&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从成为响应者开始时的累计手势移动距离为gestureState.d&#123;x,y&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onPanResponderTerminationRequest: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">    onPanResponderRelease: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 用户放开了所有的触摸点，且此时视图已经成为了响应者。</span></span><br><span class="line">      <span class="comment">// 一般来说这意味着一个手势操作已经成功完成。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onPanResponderTerminate: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 另一个组件已经成为了新的响应者，所以当前手势将被取消。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onShouldBlockNativeResponder: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个布尔值，决定当前组件是否应该阻止原生组件成为JS响应者</span></span><br><span class="line">      <span class="comment">// 默认返回true。目前暂时只支持android。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View &#123;...this._panResponder.panHandlers&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ul><li><p><a href="https://github.com/facebook/react-native/tree/master/RNTester/js/examples/PanResponder" target="_blank" rel="noopener">官方示例</a></p></li><li><p>简单的拖拽示例</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">View,</span><br><span class="line">StyleSheet,</span><br><span class="line">PanResponder</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QQAndGameHome</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        router: PropTypes.object,</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            top: JDDevice.getRpx(<span class="number">100</span>),</span><br><span class="line">            left: JDDevice.getRpx(<span class="number">100</span>),</span><br><span class="line">            bg: <span class="string">'gray'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.panResponder = PanResponder.create(&#123;</span><br><span class="line">            onStartShouldSetPanResponder: <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">            onMoveShouldSetPanResponderCapture: <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>,</span><br><span class="line">            onPanResponderGrant: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>._top = <span class="keyword">this</span>.state.top;</span><br><span class="line">                <span class="keyword">this</span>._left = <span class="keyword">this</span>.state.left;</span><br><span class="line">                <span class="keyword">this</span>.setState(&#123;<span class="attr">bg</span>: <span class="string">'red'</span>&#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onPanResponderMove: <span class="function">(<span class="params">evt, gs</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(gs.dx+<span class="string">' '</span>+gs.dy);</span><br><span class="line">                <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                    top: <span class="keyword">this</span>._top+gs.dy,</span><br><span class="line">                    left: <span class="keyword">this</span>._left+gs.dx</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            onPanResponderRelease: <span class="function">(<span class="params">evt, gs</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                    bg: <span class="string">'gray'</span>,</span><br><span class="line">                    top: <span class="keyword">this</span>._top+gs.dy,</span><br><span class="line">                    left: <span class="keyword">this</span>._left+gs.dx</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;View</span><br><span class="line">    &#123;...this.panResponder.panHandlers&#125;</span><br><span class="line">    style=&#123;[myStyles.rect,&#123;</span><br><span class="line">    <span class="string">"backgroundColor"</span>: <span class="keyword">this</span>.state.bg,</span><br><span class="line">    <span class="string">"top"</span>: <span class="keyword">this</span>.state.top,</span><br><span class="line">    <span class="string">"left"</span>: <span class="keyword">this</span>.state.left</span><br><span class="line">    &#125;]&#125;</span><br><span class="line">    &gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const myStyles = StyleSheet.create(&#123;</span></span><br><span class="line"><span class="regexp">    rect: &#123;</span></span><br><span class="line"><span class="regexp">        position: 'absolute',</span></span><br><span class="line"><span class="regexp">        width: JDDevice.getRpx(100),</span></span><br><span class="line"><span class="regexp">        height: JDDevice.getRpx(100),</span></span><br><span class="line"><span class="regexp">        borderColor: 'black'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><h2 id="TouchableHighlight-与-Touchable-系列组件"><a href="#TouchableHighlight-与-Touchable-系列组件" class="headerlink" title="TouchableHighlight 与 Touchable 系列组件"></a>TouchableHighlight 与 Touchable 系列组件</h2><blockquote><p>响应系统用起来可能比较复杂。所以我们提供了一个抽象的Touchable实现，用来做“可触控”的组件。</p></blockquote><h3 id="TouchableHighlight"><a href="#TouchableHighlight" class="headerlink" title="TouchableHighlight"></a>TouchableHighlight</h3><ul><li>本组件用于封装视图，使其可以正确响应触摸操作</li><li>按下时自带<strong>透明度降低</strong>，<strong>蒙层颜色变化</strong>反馈等效果</li><li>底层实现上，实际会创建一个新的视图到视图层级中</li><li><code>TouchableHighlight</code><strong>只支持一个子节点</strong>，（不能没有子节点也不能多于一个），如果你希望包含多个子组件，可以用一个View来包装它们</li><li><code>hitSlop</code>:这一属性定义了按钮的外延范围。这一范围也会使pressRetentionOffset变得更大。 注意： 触摸范围不会超过父视图的边界，也不会影响原先和本组件层叠的视图（保留原先的触摸优先级）。</li><li><code>onLayout</code>:当加载或者布局改变的时候被调用，参数为：<code>{nativeEvent: {layout: {x, y, width, height}}}</code></li><li><code>onLongPress</code>、 <code>onPress</code></li></ul><h3 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a>TouchableOpacity</h3><ul><li>本组件用于封装视图，使其可以正确响应触摸操作</li><li>按下时自带<strong>透明度降低</strong>效果</li><li>不透明度的变化是通过把子元素封装在一个<code>Animated.View</code>中来实现的,<strong>这个动画视图会被添加到视图层级中，少数情况下有可能会影响到布局</strong>。</li><li>此组件与<code>TouchableHighlight</code>的区别在于并<strong>没有额外的颜色变化</strong>，更适于一般场景</li></ul><h3 id="TouchableWithoutFeedback"><a href="#TouchableWithoutFeedback" class="headerlink" title="TouchableWithoutFeedback"></a>TouchableWithoutFeedback</h3><ul><li>同<code>TouchableHighlight</code>、<code>TouchableOpacity</code>的区别是按下时<strong>没有任何视觉上的反馈</strong>。</li></ul><h3 id="TouchableNativeFeedback"><a href="#TouchableNativeFeedback" class="headerlink" title="TouchableNativeFeedback"></a>TouchableNativeFeedback</h3><ul><li>本组件用于封装视图，使其可以正确响应触摸操作</li><li><strong>仅限Android平台</strong></li><li>在Android设备上，这个组件利用原生状态来渲染触摸的反馈。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React-Native, JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript ES6 类的静态方法、属性和实例方法、属性</title>
      <link href="/2019/06/05/JavaScript-ES6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/06/05/JavaScript-ES6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_30100043/article/details/53542966" target="_blank" rel="noopener">https://blog.csdn.net/qq_30100043/article/details/53542966</a></p></blockquote><ul><li>类相当于实例的原型，ES6类的声明中可以定义实例方法、实例属性和静态方法。</li><li>ES6 明确规定， Class 内部只有静态方法， 没有静态属性</li><li>ES7 有一个静态属性的提案， 目前 Babel 转码器支持。该提案允许在Class声明内部定义静态属性（属性声明前加上static关键字）</li></ul><h2 id="实例方法（属性）、静态方法（属性）的区别"><a href="#实例方法（属性）、静态方法（属性）的区别" class="headerlink" title="实例方法（属性）、静态方法（属性）的区别"></a>实例方法（属性）、静态方法（属性）的区别</h2><h3 id="实例方法、实例属性"><a href="#实例方法、实例属性" class="headerlink" title="实例方法、实例属性"></a>实例方法、实例属性</h3><h4 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h4><ul><li>实例方法定义在类的class声明里</li><li>实例属性定义在类的constructor方法里 （ES6）</li><li>ES7中类的实例属性可以用等式， 写入类的定义之中。</li></ul><a id="more"></a><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;  </span><br><span class="line">        <span class="keyword">super</span>(props);  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.state = &#123;  </span><br><span class="line">            count: <span class="number">0</span>  </span><br><span class="line">        &#125;;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.myInsProps = <span class="number">456</span>;   <span class="comment">//实例属性声明</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">let</span> myCounter = <span class="keyword">new</span> ReactCounter();</span><br><span class="line">myCounter.myInsProps;   <span class="comment">//456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES7</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">    myProp = <span class="number">42</span>;    <span class="comment">//实例属性声明</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.myProp); <span class="comment">// 42  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = <span class="keyword">new</span> MyClass ();</span><br><span class="line">myObj.myProp;     <span class="comment">//42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES7  </span></span><br><span class="line"><span class="comment">//为了可读性的目的， 对于那些在constructor里面已经定义的实例属性， 新写法允许直接列出。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;  </span><br><span class="line">        <span class="keyword">super</span>(props);  </span><br><span class="line">        <span class="keyword">this</span>.state = &#123;  </span><br><span class="line">            count: <span class="number">0</span>  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    state;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>实例变量直接调用</li></ul><h3 id="静态方法、静态属性"><a href="#静态方法、静态属性" class="headerlink" title="静态方法、静态属性"></a>静态方法、静态属性</h3><h4 id="声明方式-1"><a href="#声明方式-1" class="headerlink" title="声明方式"></a>声明方式</h4><ul><li>静态方法：可以<strong>在Class内部声明</strong>，声明方式为在前面加上 <strong>static</strong> 关键字</li><li>静态属性(ES6): 不能在Class内部声明，声明方式为通过<strong>类</strong>直接<strong>点方法赋值</strong></li><li>静态属性（ES7）：同ES6的静态方法声明方式，可以<strong>在Class内部声明</strong>，声明方式为在属性声明前加上<strong>static</strong>关键字</li></ul><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;    <span class="comment">//静态属性（类的属性）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES7:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line"><span class="keyword">static</span> prop = <span class="number">1</span>;    <span class="comment">//静态属性</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myProp); <span class="comment">// 42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>老写法的静态属性定义在类的外部。 整个类生成以后， 再生成静态属性。 这样让人很容易忽略这个静态属性， 也不符合相关代码应该放在一起的代码组织原则。 另外， 新写法是显式声明（ declarative）， 而不是赋值处理， 语义更好。</p></blockquote><h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>不会被实例继承</li><li>只能直接通过类来调用</li><li>可以被子类继承</li><li>可以从super对象上调用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;      <span class="comment">//-&gt; 静态方法在Class内部通过static关键字声明</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> classProp = <span class="number">20</span>;   <span class="comment">//静态属性（ES7写法）</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.otherProps = <span class="number">666</span>;     <span class="comment">//静态属性（ES6写法）</span></span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'     -&gt; 只能直接通过类来调用</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();  </span><br><span class="line">foo.classMethod();  <span class="comment">// TypeError: foo.classMethod is not a function  -&gt; 不会被实例继承</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.classProp);  <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.otherProps);  <span class="comment">//666</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;  </span><br><span class="line">Bar.classMethod(); <span class="comment">// 'hello'   //-&gt;可以被子类继承</span></span><br><span class="line"><span class="built_in">console</span>.log(Bar.classProp);   <span class="comment">//20  -&gt; 静态属性可以被子类继承（ES7）</span></span><br><span class="line"><span class="built_in">console</span>.log(Bar.otherProps);  <span class="comment">//666  -&gt; 静态属性可以被子类继承（ES6）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> classMethod() &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;    <span class="comment">//-&gt;可以从super对象上调用</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">Bar.classMethod();     <span class="comment">// "hello, too"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript, ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于React-Native(React)中的类型检查</title>
      <link href="/2019/06/05/%E5%85%B3%E4%BA%8EReact-Native-React-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/"/>
      <url>/2019/06/05/%E5%85%B3%E4%BA%8EReact-Native-React-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料： <a href="https://react.docschina.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">使用 PropTypes 进行类型检查</a>、<a href="https://www.jianshu.com/p/73bb6f75ed31" target="_blank" rel="noopener">ReactNative之PropTypes（七）</a>、<a href="https://juejin.im/post/5b0bb85af265da091337d236" target="_blank" rel="noopener">React 快速上手 - 10 类型检查 PropTypes</a></p></blockquote><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><h3 id="为什么要类型检查"><a href="#为什么要类型检查" class="headerlink" title="为什么要类型检查"></a>为什么要类型检查</h3><blockquote><p>我们先来看一份 rollbar 公司对 1000+ 项目的错误回收分析 top10 几乎都是因为类型而发生的错误</p><p>文章参考: <a href="https://link.juejin.im/?target=https%3A%2F%2Frollbar.com%2Fblog%2Ftop-10-javascript-errors%2F" target="_blank" rel="noopener">Top 10 JavaScript errors from 1000+ projects</a></p><p>比如定义 let prodList = [] , 你代码中 prodList.push(…)</p><p>但是初始的时候被设置 prodList = 123 而且没有任何提示, 那运行 push(…) 肯定要报未知方法的错误</p><p>这种问题在自由的 JavaScript 世界很普遍，如果在 编译 运行 两个阶段都没提示的话，排错是很麻烦的，全靠经验和对业务的熟悉 (陈年老项目又没文档简直是地狱)</p><p>所以我们要把问题消灭在萌芽中，就是申明对象的时候同时把类型也定义掉了， react 的自带方案是 PropTypes 组件</p></blockquote><blockquote><p>摘自：<a href="https://juejin.im/post/5b0bb85af265da091337d236" target="_blank" rel="noopener">React 快速上手 - 10 类型检查 PropTypes</a></p></blockquote><ul><li>类型错误（TypeError）是JavaScript世界很普遍的一种错误</li><li>类型错误 在<strong>编译</strong>、<strong>运行</strong> 两个阶段都没有提示，由于JS的这个特性，这种错误排错比较麻烦</li><li>解决方案：<ul><li>可以使用 <strong>Flow</strong> 或 <strong>TypeScript</strong> 等 JavaScript 扩展来对整个应用程序做类型检查</li><li>React 也内置了一些类型检查的功能,自带方案是 <strong>PropTypes</strong> 组件</li></ul></li></ul><a id="more"></a><h3 id="PropTypes–React的类型检查方案"><a href="#PropTypes–React的类型检查方案" class="headerlink" title="PropTypes–React的类型检查方案"></a>PropTypes–React的类型检查方案</h3><blockquote><p>注意：<br>自 React v15.5 起，<strong>React.PropTypes</strong> 已移入另一个包中。请使用<strong>prop-types</strong>库代替。</p></blockquote><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>PropTypes 提供一系列验证器，可用于确保组件接收到的数据类型是有效的</li><li>当传入的 prop 值类型不正确时，JavaScript 控制台将会显示警告</li><li>出于性能方面的考虑，propTypes 仅在开发模式下进行检查。</li><li>PropTypes必须要用static声明(或类属性)，否则无效果。</li><li>PropTypes 只能用于React框架的自定义组件，默认JS是没有的，因为它是React框架中的。</li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>要在组件的 props 上进行类型检查，你只需配置特定的 propTypes 属性：（即设置类的静态属性<strong>propTypes</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法一：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/设置propTypes静态（类）属性</span></span><br><span class="line"><span class="regexp">Greeting.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/写法二：(ES7)写法</span></span><br><span class="line"><span class="regexp">class Greeting extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/设置propTypes静态（类）属性</span></span><br><span class="line"><span class="regexp">static propTypes = &#123;</span></span><br><span class="line"><span class="regexp">        name: PropTypes.string,</span></span><br><span class="line"><span class="regexp">        onFlipEnd: PropTypes.func,</span></span><br><span class="line"><span class="regexp">        isFlipped: PropTypes.bool,</span></span><br><span class="line"><span class="regexp">   &#125;;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">   render() &#123;</span></span><br><span class="line"><span class="regexp">   return (</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/</span>h1&gt;</span><br><span class="line">    );</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查器列举"><a href="#检查器列举" class="headerlink" title="检查器列举"></a>检查器列举</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class="line">  <span class="comment">// 这些属性都是可选的。</span></span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class="line">  <span class="comment">// (或 Fragment) 也包含这些类型。</span></span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素。</span></span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class="line">  <span class="comment">// JS 的 instanceof 操作符。</span></span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class="line">  <span class="comment">// 枚举类型。</span></span><br><span class="line">  optionalEnum: PropTypes.oneOf([<span class="string">'News'</span>, <span class="string">'Photos'</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class="line">  optionalUnion: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由某一类型的值组成</span></span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由特定的类型值组成</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class="line">  <span class="comment">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任意类型的数据</span></span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class="line">  customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid prop `'</span> + propName + <span class="string">'` supplied to'</span> +</span><br><span class="line">        <span class="string">' `'</span> + componentName + <span class="string">'`. Validation failed.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class="line">  <span class="comment">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class="line">  <span class="comment">// 第一个是数组或对象本身</span></span><br><span class="line">  <span class="comment">// 第二个是他们当前的键。</span></span><br><span class="line">  customArrayProp: PropTypes.arrayOf(<span class="function"><span class="keyword">function</span>(<span class="params">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid prop `'</span> + propFullName + <span class="string">'` supplied to'</span> +</span><br><span class="line">        <span class="string">' `'</span> + componentName + <span class="string">'`. Validation failed.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以通过 PropTypes.element 来确保传递给组件的 children 中只包含一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 这必须只有一个元素，否则控制台会打印警告。</span></span><br><span class="line">    <span class="keyword">const</span> children = <span class="keyword">this</span>.props.children;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  children: PropTypes.element.isRequired</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="默认-Prop-值（defaultProps）"><a href="#默认-Prop-值（defaultProps）" class="headerlink" title="默认 Prop 值（defaultProps）"></a>默认 Prop 值（defaultProps）</h2><p>可以通过配置特定的 defaultProps 属性来定义 props 的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一（ES6）：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Hello, &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 指定 props 的默认值：</span></span><br><span class="line"><span class="regexp">Greeting.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">  name: 'Stranger'</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/写法二（ES7）:</span></span><br><span class="line"><span class="regexp">class Greeting extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  static defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">    name: 'stranger'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染出 "Hello, Stranger"：</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Greeting /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>defaultProps 用于确保 this.props.name 在父组件没有指定其值时，有一个默认值。<strong>propTypes 类型检查发生在 defaultProps 赋值后</strong>，所以类型检查也适用于 defaultProps。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript版本号大小比较</title>
      <link href="/2018/12/07/Javascript%E4%B8%AD%E7%89%88%E6%9C%AC%E5%8F%B7%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/"/>
      <url>/2018/12/07/Javascript%E4%B8%AD%E7%89%88%E6%9C%AC%E5%8F%B7%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>App的版本号”6.2.3”跟”10.5.6”比较，那个比较大呢？这个问题相信移动端的原生开发同学一定不会陌生，那么在JavaScript中如何处理类似的问题呢？</p></blockquote><p>最近在RN的开发过程中遇到了一个问题：由于RN中调用了原生模块的某个功能，但是该功能只在大于等于特定版本号的APP中才提供支持。<br>所以需要在JS代码中获取宿主APP的版本号，然后根据版本号的大小来进行适配。这样就面临着一个用JS代码进行版本号大小的比较的问题。</p><a id="more"></a><h3 id="iOS原生（Objective-C）方案"><a href="#iOS原生（Objective-C）方案" class="headerlink" title="iOS原生（Objective-C）方案"></a>iOS原生（Objective-C）方案</h3><p>我们知道在原生开发中，例如iOS开发（笔者是iOS开发出身）中，OC中的字符串对象NSString有着丰富的API来支持字符串的各种处理，其中就包括类似这种版本号比较大小的API。<br>例如做过iOS系统版本兼容适配的同学可能会见过下面这一组快捷系统版本号比较大小的宏定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//System Versioning Preprocessor Macros /</span><br><span class="line">#define SYSTEM_VERSION_EQUAL_TO(v)                  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)</span><br><span class="line">#define SYSTEM_VERSION_GREATER_THAN(v)              ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)</span><br><span class="line">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</span><br><span class="line">#define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</span><br><span class="line">#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v)     ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//适配iOS7</span><br><span class="line">#define IOS7_OR_LATER   SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;7.0&quot;)</span><br><span class="line">//适配iOS8</span><br><span class="line">#define IOS8_OR_LATER   SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;8.0&quot;)</span><br><span class="line">//适配iOS10</span><br><span class="line">#define IOS10_OR_LATER   SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;10.0&quot;)</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>IOS7_OR_LATER</code>、<code>IOS8_OR_LATER</code> 宏定义就可以用来快速的判断当前系统的iOS版本版本号是否是iOS7及以上、iOS8及以上。<br>例如: iOS7.1.0 版本上<code>IOS7_OR_LATER</code>的返回是<code>true</code>，<code>IOS8_OR_LATER</code>的返回是<code>false</code>。</p><p>上面的宏定义，实际上是用到了NSString类提供的字符串比较的API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;</span><br></pre></td></tr></table></figure><p>//使用方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *curOSVersionStr = [UIDevice currentDevice].systemVersion;</span><br><span class="line">NSComparisonResult cmpResult = [curOSVersionStr compare:@&quot;7.0&quot; options:NSNumericSearch];</span><br><span class="line">//mask选用的是NSNumericSearch，</span><br><span class="line">//NSNumericSearch的说明如下</span><br><span class="line">NSNumericSearch = 64,/* Added in 10.2; Numbers within strings are compared using numeric value, that is, Foo2.txt &lt; Foo7.txt &lt; Foo25.txt; only applies to compare methods, not find */</span><br></pre></td></tr></table></figure></p><p>可以看出，系统提供的这个字符串比较的参数选项就是用来处理类似版本号的比较场景的，是不是非常方便。</p><h3 id="JavaScript的方案"><a href="#JavaScript的方案" class="headerlink" title="JavaScript的方案"></a>JavaScript的方案</h3><p>回到正题，JavaScript语言貌似没有提供这种直接的API，仅有的String比较API完全不能满足这种需求。于是当然第一反应google一下，结果搜索到了不少文章，但是大多数文章中介绍的方法不是代码冗杂就是适应场景很有限，而且不少还有明显逻辑错误，于是决定自己写一个。不多说，直接上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本号比较</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> versionStringCompare = <span class="function">(<span class="params">preVersion=<span class="string">''</span>, lastVersion=<span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sources = preVersion.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">var</span> dests = lastVersion.split(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">var</span> maxL = <span class="built_in">Math</span>.max(sources.length, dests.length);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxL; i++) &#123;  </span><br><span class="line">        <span class="keyword">let</span> preValue = sources.length&gt;i ? sources[i]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> preNum = <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(preValue)) ? preValue.charCodeAt() : <span class="built_in">Number</span>(preValue);</span><br><span class="line">        <span class="keyword">let</span> lastValue = dests.length&gt;i ? dests[i]:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> lastNum =  <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(lastValue)) ? lastValue.charCodeAt() : <span class="built_in">Number</span>(lastValue);</span><br><span class="line">        <span class="keyword">if</span> (preNum &lt; lastNum) &#123;</span><br><span class="line">            result = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preNum &gt; lastNum) &#123; </span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例：</span></span><br><span class="line"><span class="keyword">let</span> result = versionStringCompare(<span class="string">'1.0.2'</span>, <span class="string">'1.0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = versionStringCompare(<span class="string">'1.0.0'</span>, <span class="string">'1.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">//-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = versionStringCompare(<span class="string">'11.0.2'</span>, <span class="string">'5.5.6'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = versionStringCompare(<span class="string">'5.5.0'</span>, <span class="string">'5.5'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = versionStringCompare(<span class="string">'1.1.a'</span>, <span class="string">'1.1.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);    <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>以上代码基本上兼容了各种常见的版本格式，而且代码简洁，判断结果比较符合常规思维，亲测运行结果符合预期，欢迎使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git知识总结</title>
      <link href="/2018/10/31/Git%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/10/31/Git%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="clone单个分支"><a href="#clone单个分支" class="headerlink" title="clone单个分支"></a>clone单个分支</h3><p>当远程git库体积较大，clone总是失败时，最好用以下方法Clone单个分支:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://xxx.git -b 你要的分支名 --single-branch</span><br></pre></td></tr></table></figure><p>clone成功后，想获取其他分支，用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config remote.origin.fetch <span class="string">"+refs/heads/*:refs/remotes/origin/*"</span></span><br><span class="line">git fetch --all</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="git放弃修改-amp-放弃增加文件"><a href="#git放弃修改-amp-放弃增加文件" class="headerlink" title="git放弃修改&amp;放弃增加文件"></a>git放弃修改&amp;放弃增加文件</h3><h4 id="1-本地修改了一堆文件-并没有使用git-add到暂存区-，想放弃修改。"><a href="#1-本地修改了一堆文件-并没有使用git-add到暂存区-，想放弃修改。" class="headerlink" title="1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。"></a>1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。</h4><p>单个文件/文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>所有文件/文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h4 id="2-本地新增了一堆文件-并没有git-add到暂存区-，想放弃修改。"><a href="#2-本地新增了一堆文件-并没有git-add到暂存区-，想放弃修改。" class="headerlink" title="2.本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。"></a>2.本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。</h4><p>单个文件/文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm filename / rm dir -rf</span><br></pre></td></tr></table></figure><p>所有文件/文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure><ul><li>删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！</li></ul><h4 id="3-本地修改-新增了一堆文件，已经git-add到暂存区，想放弃修改"><a href="#3-本地修改-新增了一堆文件，已经git-add到暂存区，想放弃修改" class="headerlink" title="3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改"></a>3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改</h4><p>单个文件/文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure><p>所有文件/文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure><h4 id="4-本地通过git-add-amp-git-commit-之后，想要撤销此次commit"><a href="#4-本地通过git-add-amp-git-commit-之后，想要撤销此次commit" class="headerlink" title="4. 本地通过git add &amp; git commit 之后，想要撤销此次commit"></a>4. 本地通过git add &amp; git commit 之后，想要撤销此次commit</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset commit_id</span><br></pre></td></tr></table></figure><ul><li>这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 </li><li>撤销之后，你所做的已经commit的修改还在工作区！</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><ul><li>这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 </li><li>撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。</p><ul><li><p>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。</p></li><li><p>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</p></li><li><p>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。</p></li></ul><p>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。</p><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可以通过输入 git config <key>： 来检查 Git 的某一项配置</key></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><h4 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h4><p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>跟踪文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m <span class="string">'initial project version'</span></span><br></pre></td></tr></table></figure><h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br><span class="line"></span><br><span class="line"><span class="comment">#$ git clone https://github.com/libgit2/libgit2 mylibgit  #在克隆远程仓库的时候，自定义本地仓库的名字</span></span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 </p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure><p>时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure><h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p><code>git add</code> 命令。 这是个多功能命令：</p><ul><li>可以用它开始跟踪新文件，</li><li>或者把已跟踪的文件放到暂存区，</li><li>还能用于合并时把有冲突的文件标记为已解决状态等。</li></ul><p>将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Story 182: Fix benchmarks for speed"</span></span><br><span class="line">[master 463dc4f] Story 182: Fix benchmarks <span class="keyword">for</span> speed</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><h4 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h4><p>Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m <span class="string">'added new benchmarks'</span></span><br><span class="line">[master 83e38c7] added new benchmarks</span><br><span class="line"> 1 file changed, 5 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -r <span class="comment">#查看远程分支</span></span><br><span class="line">git branch -a <span class="comment">#查看所有分支</span></span><br></pre></td></tr></table></figure><p>会显示</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">origin/HEAD -&gt; origin/master</span><br><span class="line">origin/daily/1.2.2</span><br><span class="line">origin/daily/1.3.0</span><br><span class="line">origin/daily/1.4.1</span><br><span class="line">origin/develop</span><br><span class="line">origin/feature/daily-1.0.0</span><br><span class="line">origin/master</span><br></pre></td></tr></table></figure><p>然后直接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/daily/1.4.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>数据结构学习</title>
      <link href="/2018/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><ul><li>当前进度：P66 （单链表的整表创建）</li><li>当前进度：P81  (双向链表)</li><li>当前进度：P97  (栈的链式存储结构及实现)</li><li>当前进度：P106  (后缀表达式计算结果)</li><li>当前进度：P111 （队列的定义）</li><li>当前进度：P126 (串的比较) 2018-10-30 09:25:39</li><li>当前进度：P133 (朴素的模式匹配算法) 2018-11-01 09:45:23</li><li>当前进度：P149 (树) 2018-11-02 09:51:49</li><li>当前进度：P155 (树的存储结构-双亲表示法) 2018-11-06 09:30:30</li><li>当前进度：P163 (二叉树的定义) 2018-11-07 09:24:02</li><li>当前进度：P169（二叉树的性质）2018-11-08 09:27:17</li><li>当前进度：P174 (遍历二叉树) 2018-11-14 09:50:02</li><li>当前进度：P184 (后序遍历算法) 2018-11-15 10:22:27</li><li>当前进度：P187 (二叉树的建立) 2018-11-16 09:53:13</li><li>当前进度：P-285 (赫夫曼树及其应用) 2019-01-17 09:52:43</li></ul><a id="more"></a><h2 id="重点、难点"><a href="#重点、难点" class="headerlink" title="重点、难点"></a>重点、难点</h2><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="四则运算表达式求值"><a href="#四则运算表达式求值" class="headerlink" title="四则运算表达式求值"></a>四则运算表达式求值</h4><p>想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就两步：</p><ul><li>将中缀表达式转换成后缀表达式（栈用来进出运算的附和）</li><li>将后缀表达式进行运算得出结果（栈用来进出运算的数字）</li></ul><h4 id="后缀表示法"><a href="#后缀表示法" class="headerlink" title="后缀表示法"></a>后缀表示法</h4><ul><li>一种不需要括号的后缀表达法，称之为逆波兰表示</li><li>所有的符号都是在要运算数字的后面出现的表达式</li><li>没有了括号-</li></ul><h4 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h4><p>规则</p><ul><li>从左到右遍历表达式中的每个数字和符号</li><li>遇到数字就进栈</li><li>遇到符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈</li><li>一直到最终获得结果</li></ul><h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p>转换规则</p><ul><li>从左到右遍历中缀表达式的每个数字和符号</li><li>若是数字就输出，即成为后缀表达式的一部分</li><li>若是符号，判断其与栈顶符号的优先级：优先级不高于栈顶符号（乘除优先于加减），则栈顶元素依次出栈并输出；并将当前符号进栈</li><li>若是左括号：直接进栈</li><li>若是右括号：栈顶元素依次出栈，直到匹配到左括号为止（丢弃括号）</li><li>一直到最终输出后缀表达式为止</li></ul><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>这种处理方式的原理是什么，为什么可以这么做？</p><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h4><p>子串的定位操作通常称作串的模式匹配</p><h4 id="KMP-模式匹配算法"><a href="#KMP-模式匹配算法" class="headerlink" title="KMP 模式匹配算法"></a>KMP 模式匹配算法</h4><p>P135 KMP模式匹配算法的理解 （暂时跳过）</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul><li>顺序存储结构</li><li>二叉链表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><h5 id="遍历原理"><a href="#遍历原理" class="headerlink" title="遍历原理"></a>遍历原理</h5><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层序遍历</li></ul><h5 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h5><ul><li>前序遍历算法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);<span class="comment">//显示节点数据（对接点的操作）</span></span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);  <span class="comment">//再先序遍历左子树</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);  <span class="comment">//最后先序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历算法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    InOrderTraverse(T-&gt;lchild);  <span class="comment">//中序遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);<span class="comment">//显示节点数据（对接点的操作）</span></span><br><span class="line">    InOrderTraverse(T-&gt;rchild);  <span class="comment">//最后中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历算法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);  <span class="comment">//后序遍历左子树</span></span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);  <span class="comment">//再后序遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, T-&gt;data);<span class="comment">//显示节点数据（对接点的操作）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h5><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树</li><li>已知后续遍历序列和中序遍历序列，可以唯一确定一颗二叉树</li><li>已知前序遍历序列和后续遍历序列，不能唯一确定一颗二叉树</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构、算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScrip学习笔记</title>
      <link href="/2018/09/29/JavaScrip%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/29/JavaScrip%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h2><hr><ul><li>网道（阮一峰系列） <a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">《JavaScript 教程》</a></li></ul><h3 id="当前进度"><a href="#当前进度" class="headerlink" title="当前进度"></a>当前进度</h3><ul><li>RegExp 对象 <a href="https://wangdoc.com/javascript/stdlib/regexp.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">链接</a></li></ul><h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的最大用处有两个</p><a id="more"></a><ul><li>一个是可以读取函数内部的变量，</li><li>另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ul><li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">'张三'</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。</p><p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="二进制位运算符"><a href="#二进制位运算符" class="headerlink" title="二进制位运算符"></a>二进制位运算符</h4><h5 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h5><p>位运算符可以用作设置对象属性的开关。<br>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FLAG_A = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> FLAG_B = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> FLAG_C = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> FLAG_D = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。<br>然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flags = <span class="number">5</span>; <span class="comment">// 二进制的0101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG_C) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br></pre></td></tr></table></figure><p>上面代码检验是否打开了开关C。如果打开，会返回true，否则返回false。</p><p>现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D;</span><br><span class="line"><span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure><p>上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。</p><p>有了掩码，二进制或运算可以确保打开指定的开关。(注：A、B、D)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags | mask;</span><br></pre></td></tr></table></figure><p>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（把A、B、D以外的C开关关闭）</span></span><br><span class="line">flags = flags &amp; mask;</span><br></pre></td></tr></table></figure><p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应位置取反（A B D 取反）</span></span><br><span class="line">flags = flags ^ mask;</span><br></pre></td></tr></table></figure><p>二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有位置取反</span></span><br><span class="line">flags = ~flags;</span><br></pre></td></tr></table></figure><h4 id="void-运算符-链接"><a href="#void-运算符-链接" class="headerlink" title="void 运算符 链接"></a>void 运算符 <a href="https://wangdoc.com/javascript/operators/priority.html#void-%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">链接</a></h4><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>) <span class="comment">// undefined void运算符的优先性很高，建议采用这种形式</span></span><br></pre></td></tr></table></figure><p>这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--下面这段代码中，点击链接后，会先执行onclick的代码；--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--由于onclick返回false，所以浏览器不会跳转到 example.com。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> <span class="attr">onclick</span>=<span class="string">"f(); return false;"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//以上代码可以用下面的写法（void运算符可以取代上面的写法）</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript: void(f())"</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--用户点击链接提交表单，但是不产生页面跳转。代码如下--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript: void(document.form.submit())"</span>&gt;</span></span><br><span class="line">  提交</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><h5 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'324'</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'324abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。parseInt逐个解析字符，而Number函数整体转换字符串的类型。<br>另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'42 cats'</span>) <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'42 cats'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'\t\v\r12.34\n'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'\t\v\r12.34\n'</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure><h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><h4 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h4><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">err.message <span class="comment">// "出错了"</span></span><br></pre></td></tr></table></figure><ul><li>message：错误提示信息</li><li>name：错误名称（非标准属性）</li><li>stack：错误的堆栈（非标准属性）</li></ul><h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> UserError(<span class="string">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure><p>上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。</p><h4 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h4><p>throw语句的作用是手动中断程序执行，抛出一个错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x 必须为正数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw也可以抛出自定义错误。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserError(<span class="string">'出错了！'</span>);</span><br><span class="line"><span class="comment">// Uncaught UserError &#123;message: "出错了！", name: "UserError"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">EvalError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//try...catch结构允许在最后添加一个finally代码块，</span></span><br><span class="line"><span class="comment">//表示不管是否出现错误，都必需在最后运行的语句。</span></span><br><span class="line"><span class="comment">//finally代码块用法的典型场景。</span></span><br><span class="line">openFile();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  writeFile(Data);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  handleError(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  closeFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h5><p>Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> arr         <span class="comment">// "object"      typeof运算符只能显示数组的类型是Object</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// true          Array.isArray方法可以识别数组。</span></span><br></pre></td></tr></table></figure><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><h5 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h5><ul><li>数组的valueOf方法返回数组本身。</li><li>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.toString() <span class="comment">// "1,2,3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line">arr.toString() <span class="comment">// "1,2,3,4,5,6"</span></span><br></pre></td></tr></table></figure><h5 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h5><ul><li><code>push</code> 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</li><li><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</li></ul><h5 id="shift-，unshift"><a href="#shift-，unshift" class="headerlink" title="shift()，unshift()"></a>shift()，unshift()</h5><ul><li>shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</li><li>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">a.shift() <span class="comment">// 'a'</span></span><br><span class="line">a <span class="comment">// ['b', 'c']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">b.unshift(<span class="string">'x'</span>); <span class="comment">// 4</span></span><br><span class="line">b <span class="comment">// ['x', 'a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [ <span class="string">'c'</span>, <span class="string">'d'</span> ];</span><br><span class="line">arr.unshift(<span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// [ 'a', 'b', 'c', 'd' ]</span></span><br></pre></td></tr></table></figure><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><ul><li>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</li><li>通过call方法，这个方法也可以用于字符串或类似数组的对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.join.call(<span class="string">'hello'</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="comment">// "h-e-l-l-o"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj, <span class="string">'-'</span>)</span><br><span class="line"><span class="comment">// 'a-b'</span></span><br></pre></td></tr></table></figure><h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><ul><li>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</li></ul><p>如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> oldArray = [obj];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArray = oldArray.concat();</span><br><span class="line"></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">newArray[<span class="number">0</span>].a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><ul><li>reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</li></ul><h5 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h5><ul><li>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。<code>arr.slice(start, end);</code></li><li>slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// ['a', 'b']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>));</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">//上面代码的参数都不是数组，</span></span><br><span class="line"><span class="comment">//但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。</span></span><br></pre></td></tr></table></figure><h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h5><ul><li>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</li></ul><h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><ul><li>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</li><li>sort方法不是按照大小排序，而是按照字典顺序。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>].sort()</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].sort()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">11</span>, <span class="number">101</span>].sort()</span><br><span class="line"><span class="comment">// [101, 11]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort()</span><br><span class="line"><span class="comment">// [10111, 1101, 111]</span></span><br></pre></td></tr></table></figure><ul><li>如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [111, 1101, 10111]</span></span><br></pre></td></tr></table></figure><p>上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"李四"</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"王五"</span>, <span class="attr">age</span>: <span class="number">28</span>  &#125;</span><br><span class="line">].sort(<span class="function"><span class="keyword">function</span> (<span class="params">o1, o2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; name: "李四", age: 24 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: "王五", age: 28  &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: "张三", age: 30 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><ul><li>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个<code>新数组</code>返回。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">numbers</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。</span></span><br></pre></td></tr></table></figure><ul><li>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0, 2, 6]</span></span><br></pre></td></tr></table></figure><ul><li>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[e];</span><br><span class="line">&#125;, arr)</span><br><span class="line"><span class="comment">// ['b', 'c']</span></span><br><span class="line"><span class="comment">// 上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。</span></span><br></pre></td></tr></table></figure><ul><li>如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span> &#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>].map(f) <span class="comment">// ["a", "a", "a"]</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">null</span>, <span class="number">2</span>].map(f) <span class="comment">// ["a", "a", "a"]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">2</span>].map(f) <span class="comment">// ["a", , "a"]</span></span><br><span class="line"><span class="comment">//上面代码中，map方法不会跳过undefined和null，但是会跳过空位。</span></span><br></pre></td></tr></table></figure><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h5><ul><li>forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。</li><li>如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'['</span> + index + <span class="string">'] = '</span> + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].forEach(log);</span><br><span class="line"><span class="comment">// [0] = 2</span></span><br><span class="line"><span class="comment">// [1] = 5</span></span><br><span class="line"><span class="comment">// [2] = 9</span></span><br></pre></td></tr></table></figure><ul><li>forEach方法<code>无法中断执行</code>，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。</li></ul><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><ul><li>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</li><li>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。</li><li>该方法不会改变原数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (elem &gt; <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure><h5 id="some-，every"><a href="#some-，every" class="headerlink" title="some()，every()"></a>some()，every()</h5><ul><li>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</li><li>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</li><li>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</li><li>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</li><li>对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。</li></ul><h5 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h5><ul><li>reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。</li><li>reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</li></ul><h5 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h5><ul><li>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</li><li>indexOf方法还可以接受第二个参数，表示搜索的开始位置。</li><li>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</li><li>注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScrip学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态库、动态库与FrameWork</title>
      <link href="/2018/07/27/%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8EFrameWork/"/>
      <url>/2018/07/27/%E9%9D%99%E6%80%81%E5%BA%93%E3%80%81%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8EFrameWork/</url>
      
        <content type="html"><![CDATA[<p>代码扫码（符号扫描）<br>grep “JDMobileChargeViewController” . -r -n</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/27/hello-world/"/>
      <url>/2018/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
  
  
</search>
