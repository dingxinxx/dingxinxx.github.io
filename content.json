{"meta":{"title":"在路上","subtitle":null,"description":"OC, iOS, Objective-C, JavaScript, React-Native","author":"Ding Xin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"JavaScript ES6 类的静态方法、属性和实例方法、属性","slug":"JavaScript-ES6-类的静态方法、属性和实例方法、属性","date":"2019-06-05T08:47:13.000Z","updated":"2019-06-05T09:13:07.312Z","comments":true,"path":"2019/06/05/JavaScript-ES6-类的静态方法、属性和实例方法、属性/","link":"","permalink":"http://yoursite.com/2019/06/05/JavaScript-ES6-类的静态方法、属性和实例方法、属性/","excerpt":"参考资料：https://blog.csdn.net/qq_30100043/article/details/53542966 类相当于实例的原型，ES6类的声明中可以定义实例方法、实例属性和静态方法。 ES6 明确规定， Class 内部只有静态方法， 没有静态属性 ES7 有一个静态属性的提案， 目前 Babel 转码器支持。该提案允许在Class声明内部定义静态属性（属性声明前加上static关键字） 实例方法（属性）、静态方法（属性）的区别实例方法、实例属性声明方式 实例方法定义在类的class声明里 实例属性定义在类的constructor方法里 （ES6） ES7中类的实例属性可以用等式， 写入类的定义之中。","text":"参考资料：https://blog.csdn.net/qq_30100043/article/details/53542966 类相当于实例的原型，ES6类的声明中可以定义实例方法、实例属性和静态方法。 ES6 明确规定， Class 内部只有静态方法， 没有静态属性 ES7 有一个静态属性的提案， 目前 Babel 转码器支持。该提案允许在Class声明内部定义静态属性（属性声明前加上static关键字） 实例方法（属性）、静态方法（属性）的区别实例方法、实例属性声明方式 实例方法定义在类的class声明里 实例属性定义在类的constructor方法里 （ES6） ES7中类的实例属性可以用等式， 写入类的定义之中。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940//ES6class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; this.myInsProps = 456; //实例属性声明 &#125; &#125; let myCounter = new ReactCounter();myCounter.myInsProps; //456//ES7class MyClass &#123; myProp = 42; //实例属性声明 constructor() &#123; console.log(this.myProp); // 42 &#125; &#125; let myObj = new MyClass ();myObj.myProp; //42//ES7 //为了可读性的目的， 对于那些在constructor里面已经定义的实例属性， 新写法允许直接列出。class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; state; &#125; 使用方式 实例变量直接调用 静态方法、静态属性声明方式 静态方法：可以在Class内部声明，声明方式为在前面加上 static 关键字 静态属性(ES6): 不能在Class内部声明，声明方式为通过类直接点方法赋值 静态属性（ES7）：同ES6的静态方法声明方式，可以在Class内部声明，声明方式为在属性声明前加上static关键字 代码示例： 123456789101112131415//ES6:class Foo &#123;&#125;Foo.prop = 1; //静态属性（类的属性） //ES7:class Foo &#123; static prop = 1; //静态属性&#125; class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myProp); // 42 &#125;&#125; 老写法的静态属性定义在类的外部。 整个类生成以后， 再生成静态属性。 这样让人很容易忽略这个静态属性， 也不符合相关代码应该放在一起的代码组织原则。 另外， 新写法是显式声明（ declarative）， 而不是赋值处理， 语义更好。 使用方式 不会被实例继承 只能直接通过类来调用 可以被子类继承 可以从super对象上调用 1234567891011121314151617181920212223242526272829class Foo &#123; static classMethod() &#123; //-&gt; 静态方法在Class内部通过static关键字声明 return 'hello'; &#125; static classProp = 20; //静态属性（ES7写法）&#125;Foo.otherProps = 666; //静态属性（ES6写法）Foo.classMethod() // 'hello' -&gt; 只能直接通过类来调用var foo = new Foo(); foo.classMethod(); // TypeError: foo.classMethod is not a function -&gt; 不会被实例继承console.log(Foo.classProp); //20console.log(Foo.otherProps); //666class Bar extends Foo &#123;&#125; Bar.classMethod(); // 'hello' //-&gt;可以被子类继承console.log(Bar.classProp); //20 -&gt; 静态属性可以被子类继承（ES7）console.log(Bar.otherProps); //666 -&gt; 静态属性可以被子类继承（ES6）class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; //-&gt;可以从super对象上调用 &#125; &#125; Bar.classMethod(); // \"hello, too\"","categories":[],"tags":[{"name":"JavaScript, ES6","slug":"JavaScript-ES6","permalink":"http://yoursite.com/tags/JavaScript-ES6/"}]},{"title":"关于React-Native(React)中的类型检查","slug":"关于React-Native-React-中的类型检查","date":"2019-06-05T08:45:57.000Z","updated":"2019-06-05T09:12:53.358Z","comments":true,"path":"2019/06/05/关于React-Native-React-中的类型检查/","link":"","permalink":"http://yoursite.com/2019/06/05/关于React-Native-React-中的类型检查/","excerpt":"参考资料： 使用 PropTypes 进行类型检查、ReactNative之PropTypes（七）、React 快速上手 - 10 类型检查 PropTypes 类型检查为什么要类型检查 我们先来看一份 rollbar 公司对 1000+ 项目的错误回收分析 top10 几乎都是因为类型而发生的错误 文章参考: Top 10 JavaScript errors from 1000+ projects 比如定义 let prodList = [] , 你代码中 prodList.push(…) 但是初始的时候被设置 prodList = 123 而且没有任何提示, 那运行 push(…) 肯定要报未知方法的错误 这种问题在自由的 JavaScript 世界很普遍，如果在 编译 运行 两个阶段都没提示的话，排错是很麻烦的，全靠经验和对业务的熟悉 (陈年老项目又没文档简直是地狱) 所以我们要把问题消灭在萌芽中，就是申明对象的时候同时把类型也定义掉了， react 的自带方案是 PropTypes 组件 摘自：React 快速上手 - 10 类型检查 PropTypes 类型错误（TypeError）是JavaScript世界很普遍的一种错误 类型错误 在编译、运行 两个阶段都没有提示，由于JS的这个特性，这种错误排错比较麻烦 解决方案： 可以使用 Flow 或 TypeScript 等 JavaScript 扩展来对整个应用程序做类型检查 React 也内置了一些类型检查的功能,自带方案是 PropTypes 组件","text":"参考资料： 使用 PropTypes 进行类型检查、ReactNative之PropTypes（七）、React 快速上手 - 10 类型检查 PropTypes 类型检查为什么要类型检查 我们先来看一份 rollbar 公司对 1000+ 项目的错误回收分析 top10 几乎都是因为类型而发生的错误 文章参考: Top 10 JavaScript errors from 1000+ projects 比如定义 let prodList = [] , 你代码中 prodList.push(…) 但是初始的时候被设置 prodList = 123 而且没有任何提示, 那运行 push(…) 肯定要报未知方法的错误 这种问题在自由的 JavaScript 世界很普遍，如果在 编译 运行 两个阶段都没提示的话，排错是很麻烦的，全靠经验和对业务的熟悉 (陈年老项目又没文档简直是地狱) 所以我们要把问题消灭在萌芽中，就是申明对象的时候同时把类型也定义掉了， react 的自带方案是 PropTypes 组件 摘自：React 快速上手 - 10 类型检查 PropTypes 类型错误（TypeError）是JavaScript世界很普遍的一种错误 类型错误 在编译、运行 两个阶段都没有提示，由于JS的这个特性，这种错误排错比较麻烦 解决方案： 可以使用 Flow 或 TypeScript 等 JavaScript 扩展来对整个应用程序做类型检查 React 也内置了一些类型检查的功能,自带方案是 PropTypes 组件 PropTypes–React的类型检查方案 注意：自 React v15.5 起，React.PropTypes 已移入另一个包中。请使用prop-types库代替。 特性 PropTypes 提供一系列验证器，可用于确保组件接收到的数据类型是有效的 当传入的 prop 值类型不正确时，JavaScript 控制台将会显示警告 出于性能方面的考虑，propTypes 仅在开发模式下进行检查。 PropTypes必须要用static声明(或类属性)，否则无效果。 PropTypes 只能用于React框架的自定义组件，默认JS是没有的，因为它是React框架中的。 使用方式要在组件的 props 上进行类型检查，你只需配置特定的 propTypes 属性：（即设置类的静态属性propTypes） 123456789101112131415161718192021222324252627282930313233import PropTypes from 'prop-types';//写法一：class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;//设置propTypes静态（类）属性Greeting.propTypes = &#123; name: PropTypes.string&#125;;//写法二：(ES7)写法class Greeting extends React.Component &#123; //设置propTypes静态（类）属性 static propTypes = &#123; name: PropTypes.string, onFlipEnd: PropTypes.func, isFlipped: PropTypes.bool, &#125;; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125; &#125; 检查器列举12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 你可以将属性声明为 JS 原生类型，默认情况下 // 这些属性都是可选的。 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可被渲染的元素（包括数字、字符串、元素或数组） // (或 Fragment) 也包含这些类型。 optionalNode: PropTypes.node, // 一个 React 元素。 optionalElement: PropTypes.element, // 你也可以声明 prop 为类的实例，这里使用 // JS 的 instanceof 操作符。 optionalMessage: PropTypes.instanceOf(Message), // 你可以让你的 prop 只能是特定的值，指定它为 // 枚举类型。 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 一个对象可以是几种类型中的任意一个类型 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 可以指定一个数组由某一类型的元素组成 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 可以指定一个对象由某一类型的值组成 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 可以指定一个对象由特定的类型值组成 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保 // 这个 prop 没有被提供时，会打印警告信息。 requiredFunc: PropTypes.func.isRequired, // 任意类型的数据 requiredAny: PropTypes.any.isRequired, // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。 // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。 // 它应该在验证失败时返回一个 Error 对象。 // 验证器将验证数组或对象中的每个值。验证器的前两个参数 // 第一个是数组或对象本身 // 第二个是他们当前的键。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 你可以通过 PropTypes.element 来确保传递给组件的 children 中只包含一个元素 1234567891011121314151617import PropTypes from 'prop-types';class MyComponent extends React.Component &#123; render() &#123; // 这必须只有一个元素，否则控制台会打印警告。 const children = this.props.children; return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;MyComponent.propTypes = &#123; children: PropTypes.element.isRequired&#125;; 默认 Prop 值（defaultProps）可以通过配置特定的 defaultProps 属性来定义 props 的默认值： 12345678910111213141516171819202122232425262728293031323334//写法一（ES6）：class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 指定 props 的默认值：Greeting.defaultProps = &#123; name: 'Stranger'&#125;;//写法二（ES7）:class Greeting extends React.Component &#123; static defaultProps = &#123; name: 'stranger' &#125; render() &#123; return ( &lt;div&gt;Hello, &#123;this.props.name&#125;&lt;/div&gt; ) &#125;&#125;// 渲染出 \"Hello, Stranger\"：ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example')); defaultProps 用于确保 this.props.name 在父组件没有\b指定其值时，有一个默认值。propTypes 类型检查发生在 defaultProps 赋值后，所以类型检查也适用于 defaultProps。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript版本号大小比较","slug":"Javascript中版本号大小比较","date":"2018-12-07T09:36:22.000Z","updated":"2018-12-08T03:25:11.191Z","comments":true,"path":"2018/12/07/Javascript中版本号大小比较/","link":"","permalink":"http://yoursite.com/2018/12/07/Javascript中版本号大小比较/","excerpt":"App的版本号”6.2.3”跟”10.5.6”比较，那个\b比较大呢？这个问题相信移动端的原生开发同学一定不会陌生，那么在JavaScript中如何处理类似的问题呢？ 最近在RN的开发过程中遇到了一个问题：由于RN中调用了原生模块的某个功能，但是该功能只在大于等于特定版本号的APP中才提供支持。所以需要在JS代码中获取宿主APP的版本号，然后根据版本号的大小来进行适配。这样就面临着一个用JS代码进行版本号大小的比较的问题。","text":"App的版本号”6.2.3”跟”10.5.6”比较，那个\b比较大呢？这个问题相信移动端的原生开发同学一定不会陌生，那么在JavaScript中如何处理类似的问题呢？ 最近在RN的开发过程中遇到了一个问题：由于RN中调用了原生模块的某个功能，但是该功能只在大于等于特定版本号的APP中才提供支持。所以需要在JS代码中获取宿主APP的版本号，然后根据版本号的大小来进行适配。这样就面临着一个用JS代码进行版本号大小的比较的问题。 iOS原生（Objective-C）方案我们知道在原生开发中，例如iOS开发（笔者是iOS开发出身）中，OC中的字符串对象NSString有着丰富的API来支持字符串的各种处理，其中就包括类似这种版本号比较大小的API。例如做过iOS系统版本兼容适配的同学可能会见过下面这一组快捷系统版本号比较大小的宏定义： 1234567891011121314//System Versioning Preprocessor Macros /#define SYSTEM_VERSION_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)#define SYSTEM_VERSION_GREATER_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)//适配iOS7#define IOS7_OR_LATER SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;7.0&quot;)//适配iOS8#define IOS8_OR_LATER SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;8.0&quot;)//适配iOS10#define IOS10_OR_LATER SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;10.0&quot;) 上面代码中的 IOS7_OR_LATER、IOS8_OR_LATER 宏定义就可以用来快速的判断当前系统的iOS版本版本号是否是iOS7及以上、iOS8及以上。例如: iOS7.1.0 版本上IOS7_OR_LATER的返回是true，IOS8_OR_LATER的返回是false。 上面的宏定义，实际上是用到了NSString类提供的字符串比较的API： 1- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask; //使用方法如下12345NSString *curOSVersionStr = [UIDevice currentDevice].systemVersion;NSComparisonResult cmpResult = [curOSVersionStr compare:@&quot;7.0&quot; options:NSNumericSearch];//mask选用的是NSNumericSearch，//NSNumericSearch的说明如下NSNumericSearch = 64, /* Added in 10.2; Numbers within strings are compared using numeric value, that is, Foo2.txt &lt; Foo7.txt &lt; Foo25.txt; only applies to compare methods, not find */ 可以看出，系统提供的这个字符串比较的参数选项就是用来处理类似版本号的比较场景的，是不是非常方便。 JavaScript的方案\b回到正题，JavaScript\b语言貌似没有提供这种直接的API，仅有的String比较API完全不能满足这种需求。于是当然第一反应google一下，结果搜索到了不少文章，但是大多数文章中介绍的方法不是代码冗杂就是适应场景很有限，而且不少还有明显\b逻辑错误，于是决定自己写一个。\b不多说，直接上代码 12345678910111213141516171819202122232425262728293031323334353637//版本号比较export const versionStringCompare = (preVersion='', lastVersion='') =&gt; &#123; var sources = preVersion.split('.'); var dests = lastVersion.split('.'); var maxL = Math.max(sources.length, dests.length); var result = 0; for (let i = 0; i &lt; maxL; i++) &#123; let preValue = sources.length&gt;i ? sources[i]:0; let preNum = isNaN(Number(preValue)) ? preValue.charCodeAt() : Number(preValue); let lastValue = dests.length&gt;i ? dests[i]:0; let lastNum = isNaN(Number(lastValue)) ? lastValue.charCodeAt() : Number(lastValue); if (preNum &lt; lastNum) &#123; result = -1; break; &#125; else if (preNum &gt; lastNum) &#123; result = 1; break; &#125; &#125; return result;&#125;//使用示例：let result = versionStringCompare('1.0.2', '1.0');console.log(result); //1let result = versionStringCompare('1.0.0', '1.1');console.log(result); //-1let result = versionStringCompare('11.0.2', '5.5.6');console.log(result); //1let result = versionStringCompare('5.5.0', '5.5');console.log(result); //0let result = versionStringCompare('1.1.a', '1.1.1');console.log(result); //1 以上代码\b基本上兼容了各种常见的版本格式，而且代码\b简洁，判断结果比较符合\b\b常规思维，亲测\b运行结果符合预期，欢迎使用。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Git知识总结","slug":"Git知识总结","date":"2018-10-31T03:57:57.000Z","updated":"2018-12-04T08:25:06.457Z","comments":true,"path":"2018/10/31/Git知识总结/","link":"","permalink":"http://yoursite.com/2018/10/31/Git知识总结/","excerpt":"Tipsclone单个分支当远程git库体积较大，clone总是失败时，最好用以下方法Clone单个分支: 1git clone http://xxx.git -b 你要的分支名 --single-branch clone成功后，想获取其他分支，用以下命令： 12git config remote.origin.fetch \"+refs/heads/*:refs/remotes/origin/*\"git fetch --all","text":"Tipsclone单个分支当远程git库体积较大，clone总是失败时，最好用以下方法Clone单个分支: 1git clone http://xxx.git -b 你要的分支名 --single-branch clone成功后，想获取其他分支，用以下命令： 12git config remote.origin.fetch \"+refs/heads/*:refs/remotes/origin/*\"git fetch --all git放弃修改&amp;放弃增加文件1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。单个文件/文件夹： 1git checkout -- filename 所有文件/文件夹： 1git checkout . 2.本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。单个文件/文件夹： 1rm filename / rm dir -rf 所有文件/文件夹： 1git clean -xdf 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！ 3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改单个文件/文件夹： 1git reset HEAD filename 所有文件/文件夹： 1git reset HEAD . 4. 本地通过git add &amp; git commit 之后，想要撤销此次commit1git reset commit_id 这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 撤销之后，你所做的已经commit的修改还在工作区！ 1git reset --hard commit_id 这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！ 配置Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 用户信息当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 12$ git config --global user.name \"John Doe\"$ git config --global user.email johndoe@example.com 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 12345678$ git config --listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto... 你可以通过输入 git config ： 来检查 Git 的某一项配置 12$ git config user.nameJohn Doe 获取 Git 仓库在现有目录中初始化仓库如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入： 1$ git init 跟踪文件 123$ git add *.c$ git add LICENSE$ git commit -m 'initial project version' 克隆现有的仓库克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令： 123$ git clone https://github.com/libgit2/libgit2#$ git clone https://github.com/libgit2/libgit2 mylibgit #在克隆远程仓库的时候，自定义本地仓库的名字 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 记录每次更新到仓库检查当前文件状态123$ git statusOn branch masternothing to commit, working directory clean 跟踪新文件使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行： 1$ git add README 时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态： 123456$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) new file: README 暂存已修改文件12345678$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) new file: README modified: CONTRIBUTING.md git add 命令。 这是个多功能命令： 可以用它开始跟踪新文件， 或者把已跟踪的文件放到暂存区， 还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 提交更新1234$ git commit -m \"Story 182: Fix benchmarks for speed\"[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README 好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 跳过使用暂存区域Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： 123$ git commit -a -m 'added new benchmarks'[master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-) 分支查看分支12git branch -r #查看远程分支git branch -a #查看所有分支 会显示 1234567origin/HEAD -&gt; origin/masterorigin/daily/1.2.2origin/daily/1.3.0origin/daily/1.4.1origin/developorigin/feature/daily-1.0.0origin/master 然后直接 1git checkout origin/daily/1.4.1","categories":[],"tags":[]},{"title":"数据结构学习","slug":"数据结构学习","date":"2018-10-18T00:59:55.000Z","updated":"2019-01-17T01:52:46.911Z","comments":true,"path":"2018/10/18/数据结构学习/","link":"","permalink":"http://yoursite.com/2018/10/18/数据结构学习/","excerpt":"进度 当前进度：P66 （单链表的整表创建） 当前进度：P81 (双向链表) 当前进度：P97 (栈的链式存储结构及实现) 当前进度：P106 (后缀表达式计算结果) 当前进度：P111 （队列的定义） 当前进度：P126 (串的比较) 2018-10-30 09:25:39 当前进度：P133 (朴素的模式匹配算法) 2018-11-01 09:45:23 当前进度：P149 (树) 2018-11-02 09:51:49 当前进度：P155 (树的存储结构-双亲表示法) 2018-11-06 09:30:30 当前进度：P163 (二叉树的定义) 2018-11-07 09:24:02 当前进度：P169（二叉树的性质）2018-11-08 09:27:17 当前进度：P174 (遍历二叉树) 2018-11-14 09:50:02 当前进度：P184 (后序遍历算法) 2018-11-15 10:22:27 当前进度：P187 (二叉树的建立) 2018-11-16 09:53:13 当前进度：P-285 (\b赫夫曼树及\b其应用) 2019-01-17 09:52:43","text":"进度 当前进度：P66 （单链表的整表创建） 当前进度：P81 (双向链表) 当前进度：P97 (栈的链式存储结构及实现) 当前进度：P106 (后缀表达式计算结果) 当前进度：P111 （队列的定义） 当前进度：P126 (串的比较) 2018-10-30 09:25:39 当前进度：P133 (朴素的模式匹配算法) 2018-11-01 09:45:23 当前进度：P149 (树) 2018-11-02 09:51:49 当前进度：P155 (树的存储结构-双亲表示法) 2018-11-06 09:30:30 当前进度：P163 (二叉树的定义) 2018-11-07 09:24:02 当前进度：P169（二叉树的性质）2018-11-08 09:27:17 当前进度：P174 (遍历二叉树) 2018-11-14 09:50:02 当前进度：P184 (后序遍历算法) 2018-11-15 10:22:27 当前进度：P187 (二叉树的建立) 2018-11-16 09:53:13 当前进度：P-285 (\b赫夫曼树及\b其应用) 2019-01-17 09:52:43 重点、难点栈的应用四则运算表达式求值想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就两步： 将中缀表达式转换成后缀表达式（栈用来进出运算的附和） 将后缀表达式进行运算得出结果（栈用来进出运算的数字） 后缀表示法 一种不需要括号的后缀表达法，称之为逆波兰表示 所有的符号都是在要运算数字的后面出现的表达式 没有了括号- 后缀表达式计算结果规则 从左到右遍历表达式中的每个数字和符号 遇到数字就进栈 遇到符号，就将处于栈顶的两个数字出栈，进行运算，运算结果进栈 一直到最终获得结果 中缀表达式转后缀表达式转换规则 从左到右遍历中缀表达式的每个数字和符号 若是数字就输出，即成为后缀表达式的一部分 若是符号，判断其与栈顶符号的优先级：优先级不高于栈顶符号（乘除优先于加减），则栈顶元素依次出栈并输出；并将当前符号进栈 若是左括号：直接进栈 若是右括号：栈顶元素依次出栈，直到匹配到左括号为止（丢弃括号） 一直到最终输出后缀表达式为止 思考这种处理方式的原理是什么，为什么可以这么做？ 串朴素的模式匹配算法子串的定位操作通常称作串的模式匹配 KMP 模式匹配算法P135 KMP模式匹配算法的理解 （暂时跳过） 树二叉树的存储结构 顺序存储结构 二叉链表 12345678//二叉链表结点结构定义typedef int TElementType;typedef struct BiTNode&#123; TElementType data; struct BiTNode *lchild, *rchild; //左右孩子指针&#125; BiTNode, *BiTree; 遍历二叉树遍历原理 前序遍历 中序遍历 后序遍历 层序遍历 遍历算法 前序遍历算法 123456789void PreOrderTraverse(BiTree T)&#123; if (T==NULL) &#123; return; &#125; printf(\"%c\", T-&gt;data);//显示节点数据（对接点的操作） PreOrderTraverse(T-&gt;lchild); //再先序遍历左子树 PreOrderTraverse(T-&gt;rchild); //最后先序遍历右子树&#125; 中序遍历算法 12345678910void InOrderTraverse(BiTree T)&#123; if (T==NULL) &#123; return; &#125; InOrderTraverse(T-&gt;lchild); //中序遍历左子树 printf(\"%c\", T-&gt;data);//显示节点数据（对接点的操作） InOrderTraverse(T-&gt;rchild); //最后中序遍历右子树&#125; 后序遍历算法 12345678910void PostOrderTraverse(BiTree T)&#123; if (T==NULL) &#123; return; &#125; PostOrderTraverse(T-&gt;lchild); //后序遍历左子树 PostOrderTraverse(T-&gt;rchild); //再后序遍历右子树 printf(\"%c\", T-&gt;data);//显示节点数据（对接点的操作）&#125; 推导遍历结果 已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树 已知后续遍历序列和中序遍历序列，可以唯一确定一颗二叉树 已知前序遍历序列和后续遍历序列，不能唯一确定一颗二叉树","categories":[],"tags":[{"name":"数据结构、算法","slug":"数据结构、算法","permalink":"http://yoursite.com/tags/数据结构、算法/"}]},{"title":"JavaScrip学习笔记","slug":"JavaScrip学习笔记","date":"2018-09-29T02:01:21.000Z","updated":"2019-01-14T01:38:08.877Z","comments":true,"path":"2018/09/29/JavaScrip学习笔记/","link":"","permalink":"http://yoursite.com/2018/09/29/JavaScrip学习笔记/","excerpt":"系列教程 网道（阮一峰系列） 《JavaScript 教程》 当前进度 RegExp 对象 链接 学习笔记 函数闭包闭包的最大用处有两个","text":"系列教程 网道（阮一峰系列） 《JavaScript 教程》 当前进度 RegExp 对象 链接 学习笔记 函数闭包闭包的最大用处有两个 一个是可以读取函数内部的变量， 另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 闭包的另一个用处，是封装对象的私有属性和私有方法。 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 运算符二进制位运算符开关作用位运算符可以用作设置对象属性的开关。假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。 1234var FLAG_A = 1; // 0001var FLAG_B = 2; // 0010var FLAG_C = 4; // 0100var FLAG_D = 8; // 1000 上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。 123456var flags = 5; // 二进制的0101if (flags &amp; FLAG_C) &#123; // ...&#125;// 0101 &amp; 0100 =&gt; 0100 =&gt; true 上面代码检验是否打开了开关C。如果打开，会返回true，否则返回false。 现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。 12var mask = FLAG_A | FLAG_B | FLAG_D;// 0001 | 0010 | 1000 =&gt; 1011 上面代码对A、B、D三个变量进行二进制或运算，得到掩码值为二进制的1011。 有了掩码，二进制或运算可以确保打开指定的开关。(注：A、B、D) 1flags = flags | mask; 二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。 12//（把A、B、D以外的C开关关闭）flags = flags &amp; mask; 异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。 12//对应位置取反（A B D 取反）flags = flags ^ mask; 二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。 12//所有位置取反flags = ~flags; void 运算符 链接void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。 12void 0 // undefinedvoid(0) // undefined void运算符的优先性很高，建议采用这种形式 这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。 123456789101112&lt;!--下面这段代码中，点击链接后，会先执行onclick的代码；--&gt;&lt;!--由于onclick返回false，所以浏览器不会跳转到 example.com。--&gt;&lt;script&gt;function f() &#123; console.log('Hello World');&#125;&lt;/script&gt;&lt;a href=\"http://example.com\" onclick=\"f(); return false;\"&gt;点击&lt;/a&gt;//以上代码可以用下面的写法（void运算符可以取代上面的写法）&lt;a href=\"javascript: void(f())\"&gt;文字&lt;/a&gt; 例如： 12345&lt;!--用户点击链接提交表单，但是不产生页面跳转。代码如下--&gt;&lt;a href=\"javascript: void(document.form.submit())\"&gt; 提交&lt;/a&gt; 数据类型的转换强制转换Number()1234567891011121314151617181920212223// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number('324') // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber('324abc') // NaN// 空字符串转为0Number('') // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0Number(&#123;&#125;) // NaN Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。parseInt逐个解析字符，而Number函数整体转换字符串的类型。另外，parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。 12345parseInt('42 cats') // 42Number('42 cats') // NaNparseInt('\\t\\v\\r12.34\\n') // 12Number('\\t\\v\\r12.34\\n') // 12.34 错误处理机制Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 12var err = new Error('出错了');err.message // \"出错了\" message：错误提示信息 name：错误名称（非标准属性） stack：错误的堆栈（非标准属性） 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。 123456789function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError;new UserError('这是自定义的错误！'); 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。 throw 语句throw语句的作用是手动中断程序执行，抛出一个错误 12345678910111213if (x &lt;= 0) &#123; throw new Error('x 必须为正数');&#125;// Uncaught ReferenceError: x is not defined//throw也可以抛出自定义错误。function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;throw new UserError('出错了！');// Uncaught UserError &#123;message: \"出错了！\", name: \"UserError\"&#125; try…catch 结构1234567891011121314151617181920212223try &#123; foo.bar();&#125; catch (e) &#123; if (e instanceof EvalError) &#123; console.log(e.name + \": \" + e.message); &#125; else if (e instanceof RangeError) &#123; console.log(e.name + \": \" + e.message); &#125; // ...&#125;//try...catch结构允许在最后添加一个finally代码块，//表示不管是否出现错误，都必需在最后运行的语句。//finally代码块用法的典型场景。openFile();try &#123; writeFile(Data);&#125; catch(e) &#123; handleError(e);&#125; finally &#123; closeFile();&#125; Array对象静态方法Array.isArray()Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。 1234var arr = [1, 2, 3];typeof arr // \"object\" typeof运算符只能显示数组的类型是ObjectArray.isArray(arr) // true Array.isArray方法可以识别数组。 实例方法valueOf()，toString() 数组的valueOf方法返回数组本身。 toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 12345var arr = [1, 2, 3];arr.toString() // \"1,2,3\"var arr = [1, 2, 3, [4, 5, 6]];arr.toString() // \"1,2,3,4,5,6\" push()，pop() push 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 shift()，unshift() shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 123456789101112var a = ['a', 'b', 'c'];a.shift() // 'a'a // ['b', 'c']var b = ['a', 'b', 'c'];b.unshift('x'); // 4b // ['x', 'a', 'b', 'c']var arr = [ 'c', 'd' ];arr.unshift('a', 'b') // 4arr // [ 'a', 'b', 'c', 'd' ] join() join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 通过call方法，这个方法也可以用于字符串或类似数组的对象。 123456Array.prototype.join.call('hello', '-')// \"h-e-l-l-o\"var obj = &#123; 0: 'a', 1: 'b', length: 2 &#125;;Array.prototype.join.call(obj, '-')// 'a-b' concat() concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。 1234567var obj = &#123; a: 1 &#125;;var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2 reverse() reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 slice() slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。arr.slice(start, end); slice方法的一个重要应用，是将类似数组的对象转为真正的数组。 1234567Array.prototype.slice.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;)// ['a', 'b']Array.prototype.slice.call(document.querySelectorAll(\"div\"));Array.prototype.slice.call(arguments);//上面代码的参数都不是数组，//但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组。 splice() splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 sort() sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 sort方法不是按照大小排序，而是按照字典顺序。 1234567891011['d', 'c', 'b', 'a'].sort()// ['a', 'b', 'c', 'd'][4, 3, 2, 1].sort()// [1, 2, 3, 4][11, 101].sort()// [101, 11][10111, 1101, 111].sort()// [10111, 1101, 111] 如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。 1234[10111, 1101, 111].sort(function (a, b) &#123; return a - b;&#125;)// [111, 1101, 10111] 上面代码中，sort的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于0，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。 123456789101112[ &#123; name: \"张三\", age: 30 &#125;, &#123; name: \"李四\", age: 24 &#125;, &#123; name: \"王五\", age: 28 &#125;].sort(function (o1, o2) &#123; return o1.age - o2.age;&#125;)// [// &#123; name: \"李四\", age: 24 &#125;,// &#123; name: \"王五\", age: 28 &#125;,// &#123; name: \"张三\", age: 30 &#125;// ] map() map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 1234567891011var numbers = [1, 2, 3];numbers.map(function (n) &#123; return n + 1;&#125;);// [2, 3, 4]numbers// [1, 2, 3]//numbers数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化。 map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。 1234[1, 2, 3].map(function(elem, index, arr) &#123; return elem * index;&#125;);// [0, 2, 6] map方法还可以接受第二个参数，用来绑定回调函数内部的this变量 1234567var arr = ['a', 'b', 'c'];[1, 2].map(function (e) &#123; return this[e];&#125;, arr)// ['b', 'c']// 上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。 123456var f = function (n) &#123; return 'a' &#125;;[1, undefined, 2].map(f) // [\"a\", \"a\", \"a\"][1, null, 2].map(f) // [\"a\", \"a\", \"a\"][1, , 2].map(f) // [\"a\", , \"a\"]//上面代码中，map方法不会跳过undefined和null，但是会跳过空位。 forEach() forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。 如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。 12345678function log(element, index, array) &#123; console.log('[' + index + '] = ' + element);&#125;[2, 5, 9].forEach(log);// [0] = 2// [1] = 5// [2] = 9 forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。 filter() filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。 该方法不会改变原数组。 1234[1, 2, 3, 4, 5].filter(function (elem) &#123; return (elem &gt; 3);&#125;)// [4, 5] some()，every() 这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。 它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。 some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。 reduce()，reduceRight() reduce方法和reduceRight方法依次处理数组的每个成员，最终累计为一个值。 reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 indexOf()，lastIndexOf() indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 indexOf方法还可以接受第二个参数，表示搜索的开始位置。 lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。","categories":[],"tags":[{"name":"JavaScrip学习","slug":"JavaScrip学习","permalink":"http://yoursite.com/tags/JavaScrip学习/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-27T01:37:13.383Z","updated":"2018-11-01T06:44:10.103Z","comments":true,"path":"2018/07/27/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/27/hello-world/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"静态库、动态库与FrameWork","slug":"静态库、动态库与FrameWork","date":"2018-07-27T01:37:13.383Z","updated":"2018-11-05T07:51:22.775Z","comments":true,"path":"2018/07/27/静态库、动态库与FrameWork/","link":"","permalink":"http://yoursite.com/2018/07/27/静态库、动态库与FrameWork/","excerpt":"","text":"代码扫码（符号扫描）grep “JDMobileChargeViewController” . -r -n","categories":[],"tags":[]}]}